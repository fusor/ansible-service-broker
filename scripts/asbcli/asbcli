#!/usr/bin/env python

import argparse
import base64
import requests
import getpass
import os
import sys
import json
import unicodedata
import uuid
import yaml

from requests.packages.urllib3.exceptions import InsecureRequestWarning
from subprocess import Popen, PIPE
from distutils import spawn

SCRIPT_DIR = sys.path[0]

RECORDS_FILE = '/tmp/asbcli.dat.json'
BROKER_IMAGE = 'ansibleplaybookbundle/ansible-service-broker-apb'

proc = Popen(["oc whoami -t"], stdout=PIPE, shell=True)
(TOKEN, err) = proc.communicate()

BROKER_HEADERS = {
    'X-Broker-API-Version': '2.9',
    'Authorization': 'Bearer ' + TOKEN.rstrip()
}

AVAILABLE_COMMANDS = {
    'connect': 'Connect to a broker to interact',
    'up': 'Bring up a broker in a target cluster'
}

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

def req(url, **kwargs):
    # merge in broker headers if provided
    headers = BROKER_HEADERS
    if 'headers' in kwargs:
        headers = kwargs['headers']
        headers.update(BROKER_HEADERS)
    kwargs['headers'] = headers

    verb = kwargs.pop('verb', 'get')

    return getattr(requests, verb)(url, verify=False, **kwargs)

def consumer_binding_key(key):
    # Need to perform a conversion from whatever binding key
    # was provided to the k8s delivered equiv env var
    # i.e external-mlab -> EXTERNAL_MLAB

    return key.upper().replace('-', '_')


def create_binding_record(creds, svc_record):
    ############################################################
    # TODO: HACK
    # Need to make sure parameter names line up with keys passed
    # back from credentials so we can automatically fill in params
    # on a provision with bind call. Again, this is only temporary
    # until a real service catalog can be leveraged to automatically
    # inject keys into the environment.
    #
    # Still will need some kind of key or label to tell the
    # binding consumer where to look for its binding data in the
    # environment.
    ############################################################
    return {
        'project_name': svc_record['service_id'],
        'binding_key': consumer_binding_key(svc_record['name']),
        'answers': svc_record['answers'],
    }


class App(object):
    def __init__(self, broker_address):
        self.broker_address = broker_address
        self.catalog = None
        self.opts = {
                't': ('bootstrap', self._cmd_bootstrap),
                'l': ('list services', self._cmd_list_services),
                'p': ('provision service', self._cmd_provision),
                'b': ('bind service', self._cmd_bind),
                'u': ('update service', self._cmd_update),
                'd': ('drop records', self._cmd_drop_records),
                '?': ('show menu', self._cmd_show_menu)
        }
        self._records = None

    def run(self):
        opt = ''

        self._load_records()

        self._cmd_show_menu()
        while opt != 'q':
            opt = raw_input("# ")

            if opt == 'q':
                break

            if opt not in self.opts:
                print 'ERROR: Unknown option!'
                continue

            should_quit = self.opts[opt][1]()
            if should_quit:
                break

        print 'Quitting ansibleapp client!'

    def _cmd_show_menu(self):
        print '============================================================'
        print "Select an option ('q' to quit):"
        print '============================================================'
        for k in self.opts:
            print '  %s | %s' % (k, self.opts[k][0])

    def _cmd_bootstrap(self):
        print 'Bootstrapping broker...'
        self._req_bootstrap()
        return False

    def _cmd_list_services(self):
        print 'Available services:'

        if not self.catalog:
            print ('NOTE: No services loaded in client,'
                   ' requesting catalog from broker...')
            self._req_catalog()

        self._print_service_options()
        return False

    def _cmd_provision(self):
        if not self.catalog:
            print ('No services loaded in client,'
                   ' requesting catalog from broker...')
            self._req_catalog()

        opt = None
        valid_choices = [service['num'] for service in self.catalog]
        while True:
            print 'Select a service to provision:'
            self._print_service_options()
            opt = int(raw_input('# '))  # TODO: Do this better.
            if int(opt) not in valid_choices:
                print 'ERROR: Invalid choice!'
            else:
                break
        catalog_entry = self.catalog[opt - 1]
        service = catalog_entry['service']

        print '[ %s ] selected for provisioning...' % catalog_entry['name']

        # get namespace to fill out context
        namespace = None
        while True:
            namespace = raw_input("Namespace # ")
            if namespace is not None and namespace != "":
                break

        plan_id = self._get_plan_id(service)

        sel_binding = service['id']
        answers, using_some_bind = self._get_prov_answers(service, sel_binding)

        if using_some_bind:
            print 'Using binding credentials.'
        print 'Service configured! Requesting broker to provision...'
        res, instance_id = self._req_provision(service['id'], plan_id, answers, namespace)
        print 'Provision returned status code: %s' % res.status_code
        print 'service_id: %s' % service['id']
        print 'instance_id: %s' % instance_id

        service_record = {
            'service_id': service['id'],
            'answers': answers,
            'name': catalog_entry['name'],
            'namespace': namespace,
        }
        self._set_service_record(instance_id, service_record)
        self._save_records()

        if res.status_code == 201:
            print 'Broker reported provisioning success!'
            return False
        if res.status_code == 202:
            if 'operation' in res.json():
                print "Check status of %s" % res.json()["operation"]
            return False
        else:
            print 'ERROR: Got a non-2xx code back from the broker... %d' % res.status_code
            return True

    def _cmd_update(self):
        svc_instances = self._records['service']

        updatable_opts = [(idx+1, key, svc_instances[key]['name'])
                         for idx, key in
                         enumerate(self._records['service'].keys())]

        updatable_ids = [key for a, key in
                         enumerate(self._records['service'].keys())]

        if len(updatable_opts) == 0:
            print ('No services have been provisioned;'
                   ' nothing available for bind!')
            return False

        valid_choices = [b[0] for b in updatable_opts]
        while True:
            print 'Select a service instance to update:'
            self._print_binding_menu(updatable_opts)
            opt = int(raw_input('# '))  # TODO: Do this better.

            answer = updatable_opts[opt - 1][1]
            if answer not in updatable_ids:
                print 'ERROR: Invalid choice!'
            else:
                break

        sel_binding = self._records['service'][answer]['service_id']
        if self.catalog is None:
            self._req_catalog()

        for k in self.catalog:
            if k['service']['id'] == sel_binding:
                service = k['service']

        plan_id = self._get_plan_id(service)
        answers = self._get_update_answers(service, sel_binding)
        record_answers = self._records['service'][answer]['answers']
        update_answers = record_answers.copy()
        update_answers.update(answers)

        res = self._req_update(answer, plan_id, answers)
        print res.content

    def _cmd_bind(self):
        svc_instances = self._records['service']
        bindable_opts = [(idx+1, key, svc_instances[key]['name'])
                         for idx, key in
                         enumerate(self._records['service'].keys())]

        bindable_ids = [key for a, key in
                         enumerate(self._records['service'].keys())]

        if len(bindable_opts) == 0:
            print ('No services have been provisioned;'
                   ' nothing available for bind!')
            return False

        ############################################################
        # -> HACK: create hardcoded list of params, prompt for answers
        #      Longterm, need to get params from services
        # -> _req_bind(svc_instance_id, answers)
        # -> res, binding_instance_id
        # -> set_binding_record(
        #    * binding_id -> {service_instance_id, db, user, pass}
        ############################################################
        opt = None

        binding_recs = self._records['binding']

        valid_choices = [b[0] for b in bindable_opts]
        while True:
            print 'Select a service instance to bind to:'
            self._print_binding_menu(bindable_opts)
            opt = int(raw_input('# '))  # TODO: Do this better.

            answer = bindable_opts[opt - 1][1]
            if answer not in bindable_ids:
                print 'ERROR: Invalid choice!'
            else:
                break

        sel_binding = svc_instances[key]['service_id']
        binding_namespace = svc_instances[key]['namespace']
        bind_to_app = svc_instances[key]['name'].strip('-apb')

        valid_choices = [svc[0] for svc in bindable_opts]
        while True:
            print 'Select a binding to use:'
            self._print_bindable_services(bindable_opts)
            opt = int(raw_input('# '))  # TODO: Do this better.

            if int(opt) not in valid_choices:
                print 'ERROR: Invalid choice!'
            else:
                break

        svc_to_bind = bindable_opts[opt - 1]
        svc_instance_id = svc_to_bind[1]
        svc_record = self._records['service'][svc_instance_id]

        bind_answers = self._get_bind_answers()

        res, binding_instance_id = self._req_bind(
                svc_record['service_id'], svc_instance_id, bind_answers)

        if res.status_code == 201:
            print 'Broker reported binding success!'
        else:
            print 'ERROR: Got a non-2xx code back from the broker for bind req...'
            return True

        creds = res.json()['credentials']

        binding_record = create_binding_record(creds, svc_record)
        self._set_binding_record(binding_instance_id, binding_record)
        self._save_records()

        svc_name = str(svc_record['name'])
        bind_data = self._convert_to_ascii(creds)
        self._create_secret(bind_data, svc_name)
        self._create_pod_preset(bind_data, svc_name, binding_namespace, bind_to_app)

    def _create_secret(self, bind_data, svc_name):
        print "Creating secret from bind creds"

        with open(os.path.join(SCRIPT_DIR, "secret.yaml"), 'r') as s:
            try:
                template = yaml.load(s)
            except yaml.YAMLError as err:
                print(err)

        template['metadata']['name'] = svc_name + "-secret"
        template['data'] = bind_data
        secret = template

        rendered_secret = self._render_template(secret)
        self._create_k8s_resource(rendered_secret)

    def _create_pod_preset(self, bind_data, svc_name, namespace, bind_to_app):
        print "Creating pod preset"
        with open(os.path.join(SCRIPT_DIR, "pod-preset.yaml"), 'r') as pp:
            try:
                template = yaml.load(pp)
            except yaml.YAMLError as err:
                print(err)

        template['metadata']['namespace'] = namespace
        template['metadata']['name'] = svc_name + "-bind"
        template['spec']['selector']['matchLabels']['app'] = bind_to_app
        template['spec']['env'] = self._create_secret_key_ref(svc_name, bind_data)

        pod_preset = template

        rendered_pod_preset = self._render_template(pod_preset)
        self._create_k8s_resource(rendered_pod_preset)

    def _render_template(self, template):
        path="/tmp/asbcli-resource-%s" %str(uuid.uuid4())
        print "Rendering resource template %s" %path

        with open(path, 'w') as yaml_file:
            yaml.dump(template, yaml_file, default_flow_style=False)
        return path

    def _create_k8s_resource(self, resource):
        cluster_cmd = "kubectl"
        print "Creating cluster resource: %s create -f %s" %(cluster_cmd, resource)
        cmd = "%s create -f %s" %(cluster_cmd, resource)
        os.system(cmd)

    def _create_secret_key_ref(self, name, bind_data):
        env_list = []
        for item in bind_data.keys():
            # Remove all '-' and '_'
            n = item.replace("-", "").replace("_", "")
            secret_name = name+"-secret"
            ref = {'valueFrom': {'secretKeyRef': {'name': secret_name, 'key': item}}, 'name': n.lower()}
            env_list.append(ref)
        return env_list

    def _convert_to_ascii(self, l):
        a = dict((str(k), str(v)) for k, v in l.items())
        return dict((a, base64.b64encode(b)) for a, b in a.items())

    def _cmd_drop_records(self):
        self._records = {
            'service': {},
            'binding': {},
        }
        self._drop_records()

    def _get_plan_id(self, service):
        acceptable_plan = False
        while not acceptable_plan:
            plans = list(map(lambda x: x["name"].encode('utf-8'), service["plans"]))
            print "Valid plans are: %s"%plans
            default_plan = service["plans"][0]["name"]
            plan = raw_input("Enter Plan to Provision [%s]: "%default_plan) or default_plan
            if plan in plans:
                acceptable_plan = True
            else:
                print "The plan specified is not supported by this APB. Try again."

        return plan

    def _get_prov_answers(self, service, sel_binding):
        if not sel_binding:
            print 'Configure your service:'

        using_some_bind = False
        answers = {}
        required = service['plans'][0]['schemas']['service_instance']['create']['parameters']['required']
        for param_key, param in service['plans'][0]['schemas']['service_instance']['create']['parameters']['properties'].items():
            # Accept binding value for param if its present, otherwise prompt
            param_name = param_key  # key is the new name
            binding_match = None

            if binding_match:
                answers[param_name] = binding_match
                using_some_bind = True
                continue  # skip prompt if we're accepting val from binding

            answer = None
            while True:
                supports_default = param.get('default') is not None

                if param_name not in required and not supports_default:
                    query = '%s (generated if blank) # ' % param_name
                elif supports_default:
                    query = '%s (default: %s) # ' % \
                        (param_name, param['default'])
                else:
                    query = '%s # ' % param_name
                answer = raw_input(query)

                # TODO: This is fugly. Fix it.
                should_pass = answer == '' and param_name not in required \
                    and not supports_default

                if should_pass:
                    pass
                elif answer == '' and not supports_default:
                    print 'ERROR: Must provide an answer for this parameter'
                    continue
                elif answer == '' and supports_default:
                    answer = param['default']

                answers[param_name] = answer
                break

        _answers = answers.copy()
        for k, v in answers.iteritems():
            if v == '':
                del _answers[k]

        return (_answers, using_some_bind)

    def _get_update_answers(self, service, sel_binding):
        if not sel_binding:
            print 'Configure your service:'

        using_some_bind = False
        answers = {}
        try:
            required = service['plans'][0]['schemas']['service_instance']['update']['parameters']['required']
            for param_key, param in service['plans'][0]['schemas']['service_instance']['update']['parameters']['properties'].items():
                # Accept binding value for param if its present, otherwise prompt
                param_name = param_key  # key is the new name
                binding_match = None

                if binding_match:
                    answers[param_name] = binding_match
                    using_some_bind = True
                    continue  # skip prompt if we're accepting val from binding

                answer = None
                while True:
                    supports_default = param.get('default') is not None

                    if param_name not in required and not supports_default:
                        query = '%s (generated if blank) # ' % param_name
                    elif supports_default:
                        query = '%s (default: %s) # ' % \
                            (param_name, param['default'])
                    else:
                        query = '%s # ' % param_name
                    answer = raw_input(query)

                    # TODO: This is fugly. Fix it.
                    should_pass = answer == '' and param_name not in required \
                        and not supports_default

                    if should_pass:
                        pass
                    elif answer == '' and not supports_default:
                        print 'ERROR: Must provide an answer for this parameter'
                        continue
                    elif answer == '' and supports_default:
                        answer = param['default']

                    answers[param_name] = answer
                    break
        except:
            answers = {}

        _answers = answers.copy()
        for k, v in answers.iteritems():
            if v == '':
                del _answers[k]

        return (_answers)

    def _get_bind_answers(self):
        ############################################################
        # TODO: HACK:
        # This entire method needs to be reworked. It's hardcoded
        # currently for external-mlab since the OpenServiceBroker
        # spec is still a bit in flux around how method attached
        # parameters are going to work.
        #
        # To support this dynamically, it also requires a potentially breaking
        # and destabalizing change to the ansibleapp spec.
        # This will get reviewed, ripped out and done correctly asap.
        #
        # So...here be dragons.
        ############################################################
        print 'Configure your binding:'

        HARDCODED_PARAMS = [{
            'required': True,
            'name': 'user',
        }]

        answers = {}
        for param in HARDCODED_PARAMS:
            answer = None
            while True:
                supports_default = param.get('default') is not None

                if param['required'] and not supports_default:
                    query = '%s (generated if blank) # ' % param['name']
                elif supports_default:
                    query = '%s (default: %s) # ' % \
                        (param['name'], param['default'])
                else:
                    query = '%s # ' % param['name']
                answer = raw_input(query)

                # TODO: This is fugly. Fix it.
                should_pass = answer == '' and param['required'] \
                    and not supports_default

                if should_pass:
                    pass
                elif answer == '' and not supports_default:
                    print 'ERROR: Must provide an answer for this parameter'
                    continue
                elif answer == '' and supports_default:
                    answer = param['default']

                answers[param['name']] = answer
                break

        _answers = answers.copy()
        for k, v in answers.iteritems():
            if v == '':
                del _answers[k]

        return _answers

    def _req_bootstrap(self):
        res = req(self._url('/bootstrap'), verb='post')
        if not res.ok:
            print "Problem bootstrapping broker. Status [%s]" % res.status_code
            return
        spec_count = res.json()['spec_count']
        image_count = res.json()['image_count']
        print 'Bootstrapped %d specs into broker of %d images from dockerhub!' % (spec_count, image_count)

    def _req_catalog(self):
        res = req(self._url('/catalog'))
        self.catalog = [{
            'num': idx + 1,
            'name': service['name'],
            'id': service['id'],
            'service': service,
        } for idx, service in enumerate(res.json()['services'])]
        print 'Loaded %d services from broker catalog:' % len(self.catalog)

    def _set_service_record(self, key, value):
        self._records['service'][key] = value

    def _get_service_record(self, key):
        return self._records['service'][key]

    def _set_binding_record(self, key, value):
        self._records['binding'][key] = value

    def _get_binding_record(self, key):
        return self._records['binding'][key]

    def _save_records(self):
        print "Saving records to file: %s" % RECORDS_FILE
        with open(RECORDS_FILE, 'w') as dat_file:
            json.dump(self._records, dat_file)

    def _load_records(self):
        if not os.path.exists(RECORDS_FILE):
            print "NOTE: Records file does not exist, cannot load"
            if not self._records:
                self._records = {
                    'service': {},
                    'binding': {},
                }
            return

        print "Loading records file: %s" % RECORDS_FILE
        with open(RECORDS_FILE, 'r') as dat_file:
            self._records = json.load(dat_file)

    def _drop_records(self):
        print "Dropping records file: %s" % RECORDS_FILE
        try:
            os.remove(RECORDS_FILE)
        except OSError:
            pass

############################################################
# 6 instanceUUID="688eea24-9cf9-43e3-9942-d1863b2a16af"
# 7 planUUID="4c10ff42-be89-420a-9bab-27a9bef9aed8"
# 9 serviceUUID="4240b39c-116b-40b9-9b77-2d30e229f0dc"
# 10
# 11 req="{
# 12   \"plan_id\": \"$planUUID\",
# 13   \"service_id\": \"$serviceUUID\",
# 14   \"parameters\": {
# 15     \"MYSQL_USER\": \"username\"
# 16   }
# 17 }"
# 18
# 19 curl \
# 20   -X PUT \
# 21   -H 'X-Broker-API-Version: 2.9' \
# 22   -H 'Content-Type: application/json' \
# 23   -d "$req" \
# 24   -v \
# 25   http://cap.example.com:1338/v2/service_instances/$instanceUUID
############################################################
    def _req_provision(self, service_id, plan_id, answers, namespace):
        # Generate a uuid instance ID acting as a Service Catalog would do
        instance_id = str(uuid.uuid4())
        path = '/service_instances/%s?accepts_incomplete=true' % instance_id
        context = {"platform": "kubernetes", "namespace": namespace}
        req_body = {
            'plan_id': plan_id,
            'service_id': service_id,
            'context': context,
            'parameters': answers
        }
        return (req(self._url(path), verb='put', json=req_body), instance_id)

    def _req_update(self, instance_uuid, plan_id, answers):
        path = '/service_instances/%s?accepts_incomplete=true' % instance_uuid
        req_body = {
            'instance_uuid': instance_uuid,
            'plan_id': plan_id,
            'parameters': answers
        }
        return req(self._url(path), verb='patch', json=req_body)

###############################################################################
# !/bin/bash -e

# . shared.sh

# mlab with params
# instanceUUID="8c9adf85-9221-4776-aa18-aae7b7acc436"
# req="{
#   \"plan_id\": \"$planUUID\",
#   \"service_id\": \"$serviceUUID\",
#   TODO: what are the next two keys?
#   \"app_guid\":\"\",
#   \"bind_resource\":{},
#   \"parameters\": {
#     \"user\": \"acct_one\"
#   }
# }"

# curl \
#   -X PUT \
#   -H 'X-Broker-API-Version: 2.9' \
#   -H 'Content-Type: application/json' \
#   -d "$req" \
#   -v \
#   http://cap.example.com:1338/v2/service_instances/$instanceUUID/service_bindings/$bindingUUID
###############################################################################

    def _req_bind(self, svc_id, svc_instance_id, bind_answers):
        binding_instance_id = str(uuid.uuid4())
        plan_id = str(uuid.uuid4())
        path = '/service_instances/%s/service_bindings/%s' % \
               (svc_instance_id, binding_instance_id)

        req_body = {
            'service_id': svc_id,
            'app_guid': '',
            'bind_resource': {},
            'plan_id': plan_id,
            'parameters': bind_answers,
        }
        return (req(self._url(path), verb='put', json=req_body),
                binding_instance_id)

    def _print_service_options(self):
        if self.catalog:
            for service in self.catalog:
                print '  %d | %s' % (service['num'], service['name'])
        else:
            print 'No available ansibleapps found!'

    def _print_bindable_services(self, opts):
        for svc in opts:
            print '  %d | %s | %s' % (svc[0], svc[2], svc[1])

    def _print_binding_menu(self, opts):
        for bb in opts:
            print '  %d | %s | %s' % (bb[0], bb[2], bb[1])

    def _url(self, path):
        return 'https://%s/ansible-service-broker/v2%s' % (self.broker_address, path)


def subcmd_connect_parser(parser, subcmd):
    subcmd.add_argument(
        'broker_address', action='store',
        help=u'Service Broker address <host>:<port>, ex: localhost:1338'
    )


def subcmd_up_parser(parser, subcmd):
    subcmd.add_argument(
        'cluster_address', action='store',
        help=u'Address of the cluster where the broker will be deployed'
    )
    subcmd.add_argument(
        '--cluster-user', action='store', dest='openshift_user',
        help=u'Cluster user that will be used to deploy the broker',
        required=True
    )
    subcmd.add_argument(
        '--cluster-pass', action='store', dest='openshift_pass',
        help=u'Cluster password that will be used to deploy the broker'
    )
    subcmd.add_argument(
        '--dockerhub-user', action='store', dest='dockerhub_user',
        help=u'Dockerhub user. Used to communicate with dockerhub registry.',
        required=True
    )
    subcmd.add_argument(
        '--dockerhub-pass', action='store', dest='dockerhub_pass',
        help=u'Dockerhub pass. Used to communicate with dockerhub registry.',
    )
    subcmd.add_argument(
        '--dockerhub-org', action='store', dest='dockerhub_org',
        help=u'Dockerhub org. Used to communicate with dockerhub registry.',
        default='ansibleplaybookbundle'
    )


def cmdrun_connect(**kwargs):
    App(kwargs['broker_address']).run()


def cmdrun_up(**kwargs):
    cluster = kwargs['cluster_address']
    openshift_user = kwargs['openshift_user']
    openshift_pass = kwargs['openshift_pass']
    dockerhub_user = kwargs['dockerhub_user']
    dockerhub_pass = kwargs['dockerhub_pass']
    dockerhub_org = kwargs['dockerhub_org']

    if not openshift_pass:
        openshift_pass = getpass.getpass('Enter cluster password: ')
    if not dockerhub_pass:
        dockerhub_pass = getpass.getpass('Enter dockerhub password: ')

    docker_bin = spawn.find_executable('docker')
    if not docker_bin:
        raise Exception('ERROR: Could not find docker executable.')

    # TODO: Right now, the broker will provision to the same cluster that it
    # is deployed to. Could make this configurable.
    brokerup_cmd = [
        docker_bin, 'run',
        '-e', 'OPENSHIFT_TARGET=%s' % cluster,
        '-e', 'OPENSHIFT_USER=%s' % openshift_user,
        '-e', 'OPENSHIFT_PASS=%s' % openshift_pass,
        BROKER_IMAGE, 'provision',
        '-e', 'dockerhub_user=%s' % dockerhub_user,
        '-e', 'dockerhub_pass=%s' % dockerhub_pass,
        '-e', 'dockerhub_org=%s' % dockerhub_org,
        '-e', 'openshift_target=%s' % cluster,
        '-e', 'openshift_user=%s' % openshift_user,
        '-e', 'openshift_pass=%s' % openshift_pass,
    ]

    brokerup_p = Popen(brokerup_cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    output, err = brokerup_p.communicate()

    if err:
        print "ERROR: Something went wrong trying to bring up a broker"
        raise Exception(err)

    print output


def main():
    parser = argparse.ArgumentParser(
            description=u'Utility acting as a ServiceCatalog+Client for'
            u' driving an ansible-service-broker')
    subparsers = parser.add_subparsers(title='subcommand', dest='subcommand')
    subparsers.required = True

    for subcommand in AVAILABLE_COMMANDS:
        subparser = subparsers.add_parser(
            subcommand, help=AVAILABLE_COMMANDS[subcommand]
        )
        globals()['subcmd_%s_parser' % subcommand](parser, subparser)

    args = parser.parse_args()

    try:
        globals()['cmdrun_%s' % args.subcommand](**vars(args))
    except Exception as e:
        print 'Exception occurred! %s' % e
        sys.exit(1)


if __name__ == '__main__':
    main()
